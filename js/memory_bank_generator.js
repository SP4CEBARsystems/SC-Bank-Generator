import ExtendedMath from "./extended_math.js";
import Word from "./word.js";

export default class MemoryBankGenerator {
    numberOfLocations;

    /**
     * @type {string[][]}
     */
    generatedData = [];
    
    /**
     * 
     * @param {number} numberOfLocations 
     */
    constructor(numberOfLocations) {
        this.numberOfLocations = numberOfLocations;
    }

    /**
     * 
     * @param {(bankIndex, bankPosition) => Word[]} callback 
     */
    generate(callback, numberOfLocations = 1){
        const bankArrayData = [];
        for (let bankPosition = 0; bankPosition < numberOfLocations; bankPosition++) {
            bankArrayData.push(this.generateOne(callback, bankPosition));
        }
        this.generatedData = bankArrayData;
    }

    /**
     * 
     * @param {(bankIndex, bankPosition) => Word[]} callback 
     * @param {number} bankPosition 
     * @returns {string[]}
     */
    generateOne(callback, bankPosition) {
        const bankData = ExtendedMath.sample(256, this.callbackHost, bankPosition, callback);
        const arrayLength = this.countMemoryBanksRequired(bankData);
        if (isNaN(arrayLength)) {
            const faultyIndex = bankData.findIndex((element) => isNaN(element));
            if (faultyIndex != -1) {
                console.error('invalid parameter(s) found, these are the values that your code produced:', bankData[faultyIndex], 'on index', faultyIndex, 'in', bankData);
            } else {
                console.error('invalid parameter(s) found, none of your values are NaN:', bankData);
            }
            return [];
        }
        console.log(arrayLength);
        const bankDataStrings = new Array(arrayLength).fill("");
        for (const bankValue of bankData) {
            for (const digitIndex in bankDataStrings) {
                bankDataStrings[digitIndex] += ExtendedMath.getHexDigit(bankValue, digitIndex);
            }
        }
        console.log(bankDataStrings);
        return bankDataStrings
    }

    /**
     * 
     * @param {*} bankIndex 
     * @param {*} bankPosition 
     * @param {(bankIndex, bankPosition) => Word[]} callback 
     * @returns 
     */
    callbackHost(bankIndex, bankPosition, callback){
        const output = callback(bankIndex, bankPosition);
        const out = ExtendedMath.combineOutput(output);
        // console.log(Math.abs(value), out.toString(16));
        return out;
    }

    /**
     * 
     * @param {number[]} bankData 
     * @returns 
     */
    countMemoryBanksRequired(bankData) {
        const biggestValue = Math.max(...bankData);
        return Math.ceil(ExtendedMath.getBaseLog(16, biggestValue + 1));
    }

    /**
     * 
     * @returns {string[][]}
     */
    getFormattedData(){
        return this.generatedData
            .map(element => element
                .map(element => insertNewlines(element)));

        /**
         * generated by ChatGPT
         * @param {string} str 
         * @param {number} interval 
         * @returns 
         */
        function insertNewlines(str, interval = 16) {
            return str.replace(new RegExp(`(.{${interval}})`, 'g'), '$1\n');//
        }
    }

    /**
     * 
     * @param {HTMLParagraphElement} element 
     */
    write(element) {
        element.innerHTML = this.getFormattedData()
            .reduce((previousY, elementY, indexY) => {
                console.log('elementY', elementY.length == 0, elementY)
                if (elementY.length == 0) {
                    return previousY.concat(`<br>Bank ${indexY}, obsolete<br>`);
                } else {
                    return previousY.concat(elementY
                        .reduce((previous, element, index) => 
                            previous.concat(`<br>Bank ${indexY}, digit ${index}:<br>`, element.replace(/\n/g, '<br>'))
                            ,''
                        )
                    )
                }
            },'')
        
    }
}
